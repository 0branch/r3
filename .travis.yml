#
# .travis.yaml contains YAML-formatted (http://www.yaml.org/) build
# instructions for continuous integration via Travis CI
# (http://docs.travis-ci.com/).
#


notifications:
    email: false


language: c


matrix:
    include:
        # Linux x86, release, gcc
        #
        - os: linux
          sudo: false #Force new container-based infrastructure.
          language: c
          env: OS_ID=0.4.4 DEBUG=none STANDARD=gnu89 RIGOROUS=yes STATIC=yes BUILD_FFI_CFLAGS=-m32

        # Linux x64, debug, gcc
        #
        - os: linux
          sudo: false #Force new container-based infrastructure.
          language: c
          env: OS_ID=0.4.40 DEBUG=asserts STANDARD=c RIGOROUS=yes STATIC=yes

        # Linux x64, debug, g++
        #
        # !!! Note this binary does not support c++11 completely, it's an old
        # gcc 4.6
        #
        - os: linux
          sudo: false #Force new container-based infrastructure.
          language: cpp
          env: OS_ID=0.4.40 DEBUG=asserts STANDARD=c++0x RIGOROUS=yes STATIC=yes

        # Linux x64, release, gcc
        #
        - os: linux
          sudo: false #Force new container-based infrastructure.
          language: c
          env: OS_ID=0.4.40 DEBUG=none STANDARD=gnu99 RIGOROUS=yes STATIC=yes

        # Windows x86, release, gcc
        #
        - os: linux
          sudo: false #Force new container-based infrastructure.
          language: c
          env: OS_ID=0.3.1 DEBUG=none TOOLS=i686-w64-mingw32- STANDARD=c RIGOROUS=yes STATIC=yes HOST=i686-w64-mingw32 BUILD_FFI_CFLAGS=-m32
        
        # Windows x64, debug, gcc
        #
        - os: linux
          sudo: false #Force new container-based infrastructure.
          language: c
          env: OS_ID=0.3.40 DEBUG=asserts TOOLS=x86_64-w64-mingw32- STANDARD=c RIGOROUS=yes STATIC=yes HOST=x86_64-w64-mingw32

        # Windows x64, debug, g++
        #
        # !!! Note this binary does not support c++11 or above
        #
        - os: linux
          sudo: false #Force new container-based infrastructure.
          language: cpp
          env: OS_ID=0.3.40 DEBUG=asserts TOOLS=x86_64-w64-mingw32- STANDARD=c++ RIGOROUS=yes STATIC=yes HOST=x86_64-w64-mingw32
        
        # Windows x64, release, gcc
        #
        - os: linux
          sudo: false #Force new container-based infrastructure.
          language: cpp
          env: OS_ID=0.3.40 DEBUG=none TOOLS=x86_64-w64-mingw32- STANDARD=c RIGOROUS=yes STATIC=yes

        # OSX x64, debug, gcc
        #
        # !!! Also, does not honor GCC's static linking flag for libc.
        #
        - os: osx
          osx_image: xcode8.2
          language: c
          env: OS_ID=0.2.40 DEBUG=asserts STANDARD=c99 RIGOROUS=no STATIC=no

        # OSX x64, debug, g++
        #
        # !!! Can't do all warnings as errors, because the switch for
        # files that end in .c as c++ ("-x c++") is deprecated for some overly
        # prescriptive and annoying reason.
        #
        - os: osx
          osx_image: xcode8.2
          language: cpp
          env: OS_ID=0.2.40 DEBUG=asserts STANDARD=c++14 RIGOROUS=no STATIC=no

        # OSX x64, release, gcc
        #
        # !!! Again, does not honor static linking switch.
        #
        - os: osx
          language: c
          env: OS_ID=0.2.40 DEBUG=none STANDARD=c RIGOROUS=no STATIC=no

env:
    global:
         #
         # travis encrypt AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID
         #
         - secure: "kQB+yBhlQnbJK35wyBDUHNN4SoUkWt5v5FzsdV+i9USgIatgLA33eBeRBWsmfTHWqdjBurRmomy7aNhDwKp8Viax1MhyrsYgfqkvXjnTImMGj2b/m4ltqBjTb2rQlVuhykYBR9RU4TsuX0LHVlG2xw31+VdtpQECzrnwjvsSSWwyosYdd+gg5S4TW5yNlbuyzoqVHPqc8unpj+zBUWEDAksqkvzriZvPlRjdiJR8iGTdia3ciO/+kOpHaA2yjGJRWkZWcOToDNvsZZcaQTU+iovqdWJZJdwljUMueGLD3I+pxKP3TiO79CslQD/dfL/gIj4TUc1R27fEaYGYW0v1W2yQr7trrwNeV/Oi10qSpsrXfQ10rOQ6XyhlSiWQUtwVUGredobwmAKG8IBNI32qnEJZlmQ0fyc01YXvip5EHD2FhOaK+TDK01hbXJxT4aJWgi8t+IUJO2b65jKUkhaXOtiblp2od0ZQAhH/gkgckLDwNbiHbYNBrz2mbvJli5PT26AhZ8ho5ZXa3/BTj/8A9CX1veUIykvGcRvru3lqq6PKsccfni0RxXdtuBlPxtHzsOSZy0UGEqlvPqYUpB8wEWRRt81wbh9+we46hVvvYi075sAQzw0CtPLSzSJoKFshHHY7Eo9lgbsOgirk0MiJOYLkjWsiMVMm39Oea+fHsms=" 
 
         # travis encrypt AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY
         #
         - secure: "YOW5lGwroKWQchmK+AzvN61dQ6geaYHQw0Y9eXZnWmXY8X6rjce9TnY5nWxnbHSo5cnRcP6mtSK48ce1JGrkMT0P0wpQhM+2bJfIQcmbiigRWIdrc0bQZsGkT3l+A6g9lz6VosiOlKjkxZEkzxt20+ABVc1c2ZFa8RE7ctaAfvnC/Vc0PVk3z7oQbCBVZ0H8u6HsY7zLlUrUmDPtTt7yS5VSzZf5NEvjoD3zDR7T73IFNWxW29SpdZ3jnPI67GHjshPTYj/zuAexAebI2YdV7w1EEchFqsUKskjDmr9Kkpn9BvJMZhUzCfeZVUHcQLH56h61NlFen4yhJIT/yoKSu9clRDbMhw3V3319IDTQXp/MTjXqZxZ+P1fFS81ZAt1eHvavEb5pMqVG5EJiopQTfU16TuM8sUMeuSkVwx1oSke+99qikpV1nU169KUXvQP3qksBGNMIeyRnAlQi/nYcvkJS7X4lc58lXhGpoylp7oOqk/+nlnexrmJdZQV+ixMAJ3U+OLWEDAyilGn2/Vfv7+9jlHOUtkpu6k5c0EdDvOSyOfIO/bbbIrNXnvOIheyShyfVbwjY7J9C5QDAk7AZ6mjr1ulgZU7Tk+lYrTBTjD+M1Al2q3bzYz43Ay6jKVxGZurINNB9b8DUtgma5179wqF61pMalvBfsxicYwjgQUM="
 
         - AWS_S3_BUCKET_NAME: "metaeducation"


addons:
    apt:
        packages:
            #
            # For building 32b binaries on a 64b host (not necessary when we
            # build for 64b):
            #
            - gcc-multilib
            - g++-multilib

            # For cross-compiling to Windows.
            #
            - binutils-mingw-w64-i686
            - binutils-mingw-w64-x86-64
            - gcc-mingw-w64-i686
            - gcc-mingw-w64-x86-64
            - g++-mingw-w64-i686
            - g++-mingw-w64-x86-64
            - mingw-w64

            # for makeinfo, required to build FFI
            - texinfo


install:
    #
    # Fetch a Rebol bootstrap binary, which is needed for building Rebol.
    # Travis uses the last r3-alpha that was ever published on rebol.com
    # in order to ensure that still works.
    #
    - if [[ "$TRAVIS_OS_NAME" == "linux" ]]; then wget  http://www.rebolsource.net/downloads/experimental/r3-linux-x64-gbf237fc-static && cp r3-linux-x64-gbf237fc-static make/r3-make; fi
    - if [[ "$TRAVIS_OS_NAME" == "osx" ]]; then wget http://rebolsource.net/downloads/experimental/r3-osx-x64-gbf237fc && cp r3-osx-x64-gbf237fc make/r3-make; fi
    - chmod +x make/r3-make

script:
    # Nice to know what version of gcc this is
    - ${TOOLS}gcc --version

    - TOP_DIR=${PWD}
    - |
      if [[ ${OS_ID} = "0.3.40" || ${OS_ID} = "0.3.1" ]]; then
          # Use prebuilt binaries
          if [[ ${OS_ID} = "0.3.40" ]]; then
              export PKG_CONFIG_PATH=${TOP_DIR}/external/ffi-prebuilt/lib64/pkgconfig
          else
              export PKG_CONFIG_PATH=${TOP_DIR}/external/ffi-prebuilt/lib32/pkgconfig
          fi
          # --define-prefix would be better, but it is not recognized
          export PKGCONFIG="pkg-config --define-variable=prefix=${TOP_DIR}/external/ffi-prebuilt"
          # check cflags and libs
          ${PKGCONFIG} --cflags libffi
          ${PKGCONFIG} --libs libffi
      else
          # Build libffi
          mkdir build
          cd external/libffi
          ./autogen.sh
          cd ${TOP_DIR}/build
          if [[ -z ${HOST} ]]; then
              ${TOP_DIR}/external/libffi/configure --prefix=$PWD/fakeroot CFLAGS=${BUILD_FFI_CFLAGS}
          else #cross-compiling
              ${TOP_DIR}/external/libffi/configure --prefix=$PWD/fakeroot --host=${HOST}
          fi
          make
          make install
          export PKG_CONFIG_PATH=$PWD/fakeroot/lib/pkgconfig
          # check cflags and libs
          pkg-config --cflags libffi
          pkg-config --libs libffi

          ls `pkg-config --variable=toolexeclibdir libffi`
          #remove dynamic libraries to force it to link with static libraries
          rm -f `pkg-config --variable=toolexeclibdir libffi`/*.so*
          rm -f `pkg-config --variable=toolexeclibdir libffi`/*.dylib*
          rm -f `pkg-config --variable=toolexeclibdir libffi`/*.dll*
          ls `pkg-config --variable=toolexeclibdir libffi`
      fi

    - cd ${TOP_DIR}/make/

    # Grab the abbreviated and full git commit ID into environment variables.
    # The full commit is passed to make to build into the binary, and the
    # abbreviated commit is used to name the executable.
    #
    # http://stackoverflow.com/a/42549385/211160
    #
    - GIT_COMMIT="$(git show --format="%H" --no-patch)" 
    - echo ${GIT_COMMIT}
    - GIT_COMMIT_SHORT="$(git show --format="%h" --no-patch)" 
    - echo ${GIT_COMMIT_SHORT}

    # We have to set REBOL_TOOL explicitly to circumvent the automatic r3-make
    # filename inference, as we always use Linux "r3-make" (not "r3-make.exe")
    # even when doing windows builds, since this is a cross-compilation.
    #
    # As an extra step to test bootstrap ability, we make the 64-bit debug
    # build go even further by doing another full build, but using the 
    # just built r3 as its own r3-make.
    #
    - |
      if [[ ("${OS_ID}" = "0.4.40" || "${OS_ID}" = "0.2.40") && "${DEBUG}" != "none" ]]; then
          #
          # If building twice, don't specify GIT_COMMIT for the first build.
          # This means there's a test of the build process when one is not
          # specified, in case something is broken about that.  (This is how
          # most people will build locally, so good to test it.)
          #
          # Also request address sanitizer to be used for the first build.  It
          # is very heavyweight and makes the executable *huge* and slow, so
          # we do not apply it to any of the binaries which are uploaded to s3
          # -- not even debug ones.
          #
          make -f makefile.boot REBOL_TOOL=r3-make STANDARD="${STANDARD}" OS_ID="${OS_ID}" RIGOROUS="${RIGOROUS}" DEBUG=sanitize STATIC=no

          rm r3-make;
          mv r3 r3-make;
          make clean;
          export R3_ALWAYS_MALLOC=1
      fi

    # On the second build of building twice, or just building once, include
    # the GIT_COMMIT
    #
    - make -f makefile.boot REBOL_TOOL=r3-make STANDARD="${STANDARD}" OS_ID="${OS_ID}" DEBUG="${DEBUG}" GIT_COMMIT="${GIT_COMMIT}" RIGOROUS="${RIGOROUS}" STATIC="${STATIC}" WITH_FFI="dynamic"

    # output the needed libraries
    - |
      if [[ "${OS_ID}" = "0.4.40" || "${OS_ID}" = "0.4.4" ]]; then
          ldd ./r3
      elif [[ "${OS_ID}" = "0.2.40" ]]; then
          otool -L ./r3
      fi


    # Run once but don't pipe output, in case it prints out useful crash msg
    # that we want to see in the Travis log (especially helpful for failures
    # only happening in the Travis builds that aren't reproducing locally)
    # Save the exit code ($?) so we can return it to Travis as last step
    #
    # !!! This is a very minimal sanity check to ensure the built R3 does
    # *something*, and it can obviously only be used on the linux version.
    # Running the full test suite would be a bit much, and developers are
    # expected to have already done that.  But doing an HTTPS read exercises
    # a fair amount of code.
    #
    - |
      if [[ "${OS_ID}" = "0.4.40" || "${OS_ID}" = "0.4.4" || "${OS_ID}" = "0.2.40" ]]; then
          ./r3 --do "print {Testing...} quit/with either find to-string read https://example.com {<h1>Example Domain</h1>} [0] [1]";
          R3_EXIT_STATUS=$?;
      else
          R3_EXIT_STATUS=0;
      fi
    - echo ${R3_EXIT_STATUS}
    
    # Run basic testing with FFI, this is a linux-only script
    - |
      if [[ "${OS_ID}" = "0.4.40" || "${OS_ID}" = "0.4.4" ]]; then
          ./r3 ../tests/misc/qsort_r.r
          R3_EXIT_STATUS=$?;
      else
          R3_EXIT_STATUS=0;
      fi
    - echo ${R3_EXIT_STATUS}

    # Delete the obj file directory so we don't upload those to S3
    #
    - rm -rf objs

    # Name the executable based on the abbreviated commit, whether it is a
    # debug or release build, and if it was built using C++ or not.  Note that
    # the C++ debug builds have additional runtime checks in the debug
    # build...though there should not be any impact on the release build.
    # (Though there may be additional DLL dependencies regardless.)
    #
    # !!! All Ren-C stakeholders should be using debug builds at this time.  
    #
    # Note: -z tests if a variable is undefined
    #
    - NEW_NAME=${OS_ID}/r3-${GIT_COMMIT_SHORT}
    - if [[ "${DEBUG}" = "yes" ]]; then NEW_NAME+="-debug"; fi 
    - |
      if [[ "${STANDARD}" = "c++" || "${STANDARD}" = "c++0x" || "${STANDARD}" = "c++11" || "${STANDARD}" = "c++14" || "${STANDARD}" = "c++17" ]]; then
          NEW_NAME+="-cpp";
      fi
    - echo ${NEW_NAME}

    # Move the executable into a directory based on its OS_ID platform.
    # This is because the deploy step is run for each OS and would
    # otherwise overwrite executables in the same location.
    #
    - mkdir ${OS_ID}
    - |
      if [[ -e "r3.exe" ]]; then
           mv r3.exe ${NEW_NAME}.exe;
      else
           mv r3 ${NEW_NAME};
      fi

    # Return whether the build succeeded or not to Travis.  If this succeeded 
    # then the deploy step to S3 will run
    #
    # http://stackoverflow.com/a/10457902/211160
    #
    - (exit ${R3_EXIT_STATUS})


# After everything is finished (e.g. script section above), upload build 
# product to Amazon S3.  For how the configuration works and manages to keep
# the private key secure, see:
#
# http://stackoverflow.com/a/42547424/211160
#
deploy:
    provider: s3
    access_key_id: $AWS_ACCESS_KEY_ID
    secret_access_key: $AWS_SECRET_ACCESS_KEY
    bucket: $AWS_S3_BUCKET_NAME
    skip_cleanup: true
    upload-dir: travis-builds
